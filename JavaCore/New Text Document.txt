1. Что такое класс Object? Какие в нем есть методы?
Object это базовый класс для всех остальных объектов в Java. Каждый класс наследуется от Object. Соответственно все классы наследуют методы класса Object.
Методы класса Object:
public final native Class getClass()
public native int hashCode()
public boolean equals(Object obj)
protected native Object clone() throws CloneNotSupportedException
public String toString()
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanos) throws InterruptedException
public final void wait() throws InterruptedException
protected void finalize() throws Throwable

2. Что такое метод equals(). Чем он отличается от операции ==.
Метод equals предназанчен для проверки двух объектов на эквивалентость (то есть эти объекты сравниваются по данным/ключевым полям). 
А оператор == предназначен для сравнения ссылок двух переменных (то есть ссылаются ли две разные переменные на один и тот же объект). 
По умолчанию, для всех класов в которых метод equals не переопределён, он будет сравнивать ссылки на обекты.

3. Если вы хотите переопределить equals(), какие условия должны удовлетворяться для переопределенного метода?
Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным. 
Рефлексивность: для любого ненулевого x, x.equals(x) вернет true;
Транзитивность: для любого ненулевого x, y и z, если x.equals(y) и y.equals(z) вернет true, тогда и x.equals(z) вернет true;
Симметричность: для любого ненулевого x и y, x.equals(y) должно вернуть true, тогда и только тогда, когда y.equals(x) вернет true.
Также для любого ненулевого x, x.equals(null) должно вернуть false.

4. Если equals() переопределен, есть ли какие-либо другие методы, которые следует переопределить?
hashCode()

5. Для чего нужен метод hashCode()?
Вычисление хэш-функции лежит в основе таких известных классов, как HashMap, HashSet, Hashtable. 
Именно за счет хэша мы можем вставлять и получать данные за O(1), то есть за время пропорциональное вычислению хэш-функции.
То есть ответ на вопрос заключается в том, что существуют коллекции(HashMap, HashSet), 
которые используют хэш код, как основу при работе с объектами. 
А если хэш для равных объектов будет разным, то в HashMap будут два равных значения, что является ошибкой. 
Поэтому необходимо соответствующим образом переопределить метод hashCode().

6. Какая связь между hashCode и equals?
Эквивалентность и хеш-код тесно связанны между собой, поскольку хеш-код вычисляется 
на основании содержимого объекта (значения полей) и если у двух объектов одного и того же класса содержимое одинаковое, 
то и хеш-коды должны быть одинаковые.Но необязательно, чтобы два различных объекта возвращали различные хэш коды(такая ситуация называется коллизией).

7. Каким образом реализованы методы hashCode и equals в классе Object?
equals использует ==. Реализация же метода hashCode класса Object сделана нативной, т.е. определенной не с помощью Java-кода:
public native int hashCode();
Он обычно возвращает адрес объекта в памяти.

8. Что будет, если переопределить equals не переопределяя hashCode? Какие могут возникнуть проблемы?
Они будут неправильно хранится в контейнерах, использующих хэш коды, таких как HashMap, HashSet. Хеши для одинаковых обектов будут разными, 
а следовательно в данных структурах будут храниться в 2 экземплеярах.

9. Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode?
Есть. Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid, например. Причем, если эти поля задействованы при вычислении hashCode, то нужно их задействовать при выполнении equals.
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.

10. Как вы думаете, будут ли какие-то проблемы, если у объекта, который используется в качестве ключа в hashMap изменится поле, которое участвует в определении hashCode?
Будут. Опять же будут проблемы связанные с хэш коллекциями. А именно, не сможем выбрать элемент из хэш-коллекции, его как будто и не будет.

11. Какие модификаторы доступа в Java вы знаете?
public, private, protected, default (package-private)

12. Какой из модификаторов более строгий: protected или package-private?
default (package-private) (модификатор, по-умолчанию): члены класса видны внутри пакета (если класс будет так объявлен он будет доступен только внутри пакета);
protected: видимость в пакете + в наследниках

13. Если у класса-родителя есть метод, объявленный как private, может ли наследник расширить его видимость? А если protected? А сузить видимость?
Расширить можно, сузить нельзя.

14. Что означает ключевое слово final?
Класс, объявленный, объявленный с модификатором 'final' не может иметь подклассов. 
Метод final реализуется точно однажды, в объявлении класса. Такой метод не может быть отменен: подклассы не могут заменить метод новым определением. 
Переменная final может быть установлена только однажды, разрешая нам объявить частые константы.

15. Имеет ли смысл объявлять метод private final?
В таком случае добавления ключевого слова final не вызовет проблем, но и не произведёт положительного эффекта. 
Все компиляторы интерпретируют private методы, как final (по сути они ими и являются), а то, 
будет ли компилятор использовать дополнительную оптимизацию только для private final методов, зависит только от самого компилятора.

16. Какие особенности инициализации final переменных?
Если final переменная, объявленная как не static, не инициализируется при объявлении или этого ЯВНО не происходит в теле конструктора или блоке инициализации, то это приведет к ошибке компиляции.
Final переменные, объявленные как static, должны быть проинициализированы при объявлении или в блоке инициализации, также объявленном как static. В противном случае, опять получится ошибка компиляции.

17. Что будет, если единственный конструктор класса объявлен как final?
Ошибка компиляции. Так как конструкторы не наследуются, то нет смысла объявлять их final. 

18. Что означает ключевое поле static?
То, что метод, внутренний класс или поле является экземплярами класса. 
Так же существует static блок, который выполняется при загрузке класса. 

19. К каким конструкциям Java применим модификатор static?
К методам и данным, внутренним классам и импорту.

20. Что будет, если в static блоке кода возникнет исключительная ситуация?
Если unchecked исключение вывалится в static-блоке, то класс не будет инициализирован. 

21. Можно ли перегрузить static метод?
Перезагрузить можно, переописать нельзя.

22. Что такое статический класс, какие особенности его использования?
Это вложенный класс, который может обращаться только к статическим полям обертывающего его класса, в том числе и приватным. 
Доступ к нестатическим полям обрамляющего класса может быть осуществлен только через ссылку на экземпляр обрамляющего объекта.

23. Какие особенности инициализации final static переменных?
Переменный должны быть инициализированы во время объявления или в static блоке.

24. Какие типы классов бывают в java (вложенные… и.т.д.)
Обычные классы
Статические вложенные классы (Static nested classes)
Внутренние классы-члены (Member inner classes)
Локальный класс (Local inner classes)
Анонимные классы (Anonymous inner classes)

25. Каким образом из вложенного класса получить доступ к полю внешнего класса.
Если вложенный класс не статический и поле не статическое, то можно просто обратиться к этому полю из внутреннего класса, 
если только у внутреннего класса не существует поля с таким же литералом, 
в этом случае нужно обраться через ссылку на внешний класс где-то так - OuterClass.this

26. Какие особенности создания вложенных классов: простых и статических.
Простые вложенные классы не могут иметь статических методов и переменных. Внутри такого класса нельзя объявить перечисления.

27. Каким образом можно обратиться к локальной переменной метода из анонимного класса, объявленного в теле этого метода? Есть ли каке-нибудь ограничения для такой переменной?
Эта переменная в методе содержащем анонимный класс должна быть final, иначе ошибка компиляции. Обратиться к ней можно напрямую.

28. Какие вы знаете способы запустить некоторое действие в отдельном потоке?
наследовать поток или импелментить Runnable

29. Какие вы знаете способы прекратить выполнение потока?
Thread.stop(); // depreceted
При вызове метода interrupt(), флаг прерывания устанавливается в true, после чего в потоке должен быть реализован метод его завершения (выход из метода run()).

30. Какие ключевые слова Java, связанные с многопоточностью Вы знаете?
valotile - помечает объект, чтобы он не кэшировался отдельно для каждого потока. Все запросы к переменной будут направляться непосредственно в память.
syhcronized.

31. Для чего используется ключевое слово syhcronized?
блок кода только одним потоком

32. Есть некоторый метод, который исполняет операцию i++. Переменная i типа int. 
Предполагается, что код будет исполнятся в многопоточной среде. Следует ли синхронизировать блок?
Следует. Инкремент/декремент - не атомарные операции.

33. Что служит в качестве mutex, если метод объявлен synchronized?
Объект, чей метод вызывается

34. Можно ли вызвать в разных потоках два synchronized метода одного и того же объекта?
Можно, но они будут выполняться не одновременно, так как блокировака по объекту

35. Что используется в качестве mutex, если метод объявлен static synchronized? Можно ли создавать новые экземпляры класса, пока выполняется static synchronized метод?
Монитор класса(контролит всю статику) Можно

36. Объясните, что такое deadlock? Приведите пример кода, который демонстрирует deadlock.
Ситуация, когда несколько потоков находятся в состоянии бесконечного ожидания в следствии ожидания освобождения ресурсов, которые сами же и занимают.
public class SimpleDeadLock {
   public static Object l1 = new Object();
   public static Object l2 = new Object();
   private int index;
   public static void main(String[] a) {
      Thread t1 = new Thread1();
      Thread t2 = new Thread2();
      t1.start();
      t2.start();
   }
   private static class Thread1 extends Thread {
      public void run() {
         synchronized (l1) {
            System.out.println("Thread 1: Holding lock 1...");
            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Thread 1: Waiting for lock 2...");
            synchronized (l2) {
               System.out.println("Thread 2: Holding lock 1 & 2...");
            }
         }
      }
   }
   private static class Thread2 extends Thread {
      public void run() {
         synchronized (l2) {
            System.out.println("Thread 2: Holding lock 2...");
            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Thread 2: Waiting for lock 1...");
            synchronized (l1) {
               System.out.println("Thread 2: Holding lock 2 & 1...");
            }
         }
      }
   }
}

37. Для чего используется ключевое слово volatile?
valotile - помечает объект, чтобы он не кэшировался отдельно для каждого потока. Все запросы к переменной будут направляться непосредственно в память.

38. Какие особенности использования метода wait? При каких условиях поток может выйти из режима ожидания?
class MyHouse {
    private boolean pizzaArrived = false;

    public void eatPizza(){
        synchronized(this){
            while(!pizzaArrived){
                wait();
            }
        }
        System.out.println("yumyum..");
    }

    public void pizzaGuy(){
        synchronized(this){
             this.pizzaArrived = true;
             notifyAll();
        }
    }
}
Если задан параметр/параметры, определяющий время и если поток не будет разбужен в течении этого времени при помощи методов notify() или notifyAll(), тогда он будет разбужен по прошествии указанного времени.
Если не задан параметр/параметры, определяющие время, то поток будет разбужен только при помощи методов notify() или notifyAll().

39. Предположим в методе run возник RuntimeException, который не был пойман. Что случится с потоком? 
Есть ли способ узнать о том, что Exception произошел (не заключая все тело run в блок try-catch)? 
Есть ли способ восстановить работу потока после того как это произошло?

Поток будет остановлен. Нет. Нет.

40. Какие стандартные инструменты Java вы бы использовали для реализации пула потоков?
LinkedList, synchronized, wait(), notify()/notifyAll(). Уже есть стандартное решение 

41. Какие виды исключений в Java вы знаете, чем они отличаются?
RuntimeException | Error

42. Назовите несколько классов из вершины иерархии исключений в Java.
Throwable, 1.Error, 2.Exception, 1.1.RuntimeException

43. Что такое Error? В каком случае используется Error. Приведите пример Error’а.
StackOverflow (системные ошибки)

44. Какая конструкция используется в Java для обработки исключений?
try - catch - finaly

45. Возможно ли использование блока try-finally (без catch)?
Да

46. Предположим, есть блок try-finally. В блоке try возникло исключение и выполнение переместилось в блок finally. В блоке finally тоже возникло исключение. Какое из двух исключений “выпадет” из блока try-finally? Что случится со вторым исключением?
первое не будет обрабатываться

47. Всегда ли исполняется блок finally?
Только если поток ещё исполняется и JVM ещё работает к этому моменту.

48. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?
try {
        System.exit(1);
} finaly {
        System.out.println("42");
}

49. Предположим, есть метод, который может выбросить IOException и FileNotFoundException в какой последовательности должны идти блоки catch? Сколько блоков catch будет выполнено?
FileNotFoundException --> IOException . Выполнен только 1й блок будет. http://i.piccy.info/i9/2579c05514d2f6424a63e4d246ffb0ad/1398970263/143501/740281/exceptions.png

50. Предположим вам необходимо создать свой собственный класс Exception. Какими мотивами вы будете руководствоваться при выборе типа исключения: checked/unchecked?
Дело в том, что если проверять каждое место, где теоретически может быть ошибка, то ваш код сильно разрастется, станет плохо читаемым.

http://habrahabr.ru/post/136766/